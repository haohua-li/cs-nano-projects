# Inter-Process Communication 

The following content is generated by ChatGPT 

<https://chat.openai.com/share/e/afb99653-19fd-470c-a352-76c3f7bbcb6e>

and 

<https://zhuanlan.zhihu.com/p/58489873>


IPC, or Inter-process Communication, is a mechanism that allows the processes of an operating system to communicate and synchronize their actions. In Linux, IPC is used extensively to enable processes to coordinate their operations and share data efficiently. Several methods of IPC in Linux include:

1. Pipes and FIFOs(named pipes)
2. Signals
3. Message Queues
4. Semaphores
5. Shared Memory
6. Sockets
7. Memory Mapped Files

## Pipes and FIFOs:

Pipes are used for communication between related processes; they operate on a producer-consumer principle where one process writes to the pipe and the other reads from it.

Named Pipes (FIFOs) extend the functionality of pipes to unrelated processes, allowing communication using a name in the filesystem.

### (Anonymous) Pipe 

匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。

#### Shell Example 

```shell 
ls | grep "txt"
```

#### C Example (PIPE)

我们可以把匿名管道和命名管道分别叫做PIPE和FIFO。这主要因为在系统编程中，创建匿名管道的系统调用是`pipe()`，而创建命名管道的函数是`mkfifo()`。使用`mknod()`系统调用并指定文件类型为为`S_IFIFO`也可以创建一个FIFO。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefds[2];
    pid_t pid;
    const char *msg = "Hello from parent to child!";
    char buffer[100];

    // Create a pipe (unamed)
    if (pipe(pipefds) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Fork a child process (child process has the address of unamed pipe)
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Child process
        close(pipefds[1]); // Close unused write end

        // Read data from pipe
        read(pipefds[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);

        close(pipefds[0]); // Close read end
        exit(EXIT_SUCCESS);
    } else {
        // Parent process
        close(pipefds[0]); // Close unused read end

        // Write data to pipe
        write(pipefds[1], msg, strlen(msg) + 1);
        printf("Parent sent: %s\n", msg);

        close(pipefds[1]); // Close write end

        wait(NULL); // Wait for child to finish
        exit(EXIT_SUCCESS);
    }
}
```


### Named Pipe 

我们可以使用mkfifo或mknod命令来创建一个命名管道，这跟创建一个文件没有什么区别：

#### Shell Example 

Writer script (`writer.sh`):

```shell
#!/bin/bash
# Check if FIFO exists, if not, create it
if [ ! -p myfifo ]; then
    mkfifo myfifo
fi

# Write data into the FIFO
echo "Data from the writer process" > myfifo
```

Reader script (`reader.sh`):

```shell 
#!/bin/bash
# Check if FIFO exists, if not, inform the user
if [ ! -p myfifo ]; then
    echo "FIFO 'myfifo' does not exist."
    exit 1
fi

# Read data from the FIFO
while true
do
  if read line <myfifo; then
    echo "Received: $line"
  fi
done
```

#### C Example (FIFO)

我们可以把匿名管道和命名管道分别叫做PIPE和FIFO。这主要因为在系统编程中，创建匿名管道的系统调用是`pipe()`，而创建命名管道的函数是`mkfifo()`。使用`mknod()`系统调用并指定文件类型为为`S_IFIFO`也可以创建一个FIFO。


This example involves two separate programs: one for writing to the named pipe (writer) and another for reading from the named pipe (reader).

Writer Program (`writer.c`):

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    int fd;
    const char *fifo_path = "/tmp/myfifo";
    const char *message = "Hello from the writer!";

    // Create a FIFO named pipe
    mkfifo(fifo_path, 0666);

    // Open the FIFO for writing
    fd = open(fifo_path, O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Write data to the FIFO
    write(fd, message, sizeof(char) * (strlen(message) + 1));
    printf("Data written to FIFO: %s\n", message);

    // Close the FIFO
    close(fd);

    // Remove the FIFO from the filesystem (optional)
    unlink(fifo_path);

    return 0;
}
```


Reader Program (`reader.c`):

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    int fd;
    const char *fifo_path = "/tmp/myfifo";
    char buffer[100];

    // Open the FIFO for reading
    fd = open(fifo_path, O_RDONLY);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Read data from the FIFO
    read(fd, buffer, sizeof(buffer));
    printf("Data received from FIFO: %s\n", buffer);

    // Close the FIFO
    close(fd);

    return 0;
}
```

Compile the writer and reader program.

```shell
gcc writer.c -o writer
gcc reader.c -o reader 
```

##### Explanation 

##### FIFO Creation:

`mkfifo(fifo_path, 0666)`; creates a named pipe with read and write permissions for all users.

##### Opening the FIFO:

In the writer, `open(fifo_path, O_WRONLY)`; opens the FIFO for writing.
In the reader, `open(fifo_path, O_RDONLY)`; opens the FIFO for reading.

##### Reading and Writing:

The writer writes a message to the FIFO.
The reader reads the message from the FIFO.

##### Cleanup

The writer closes and optionally removes the FIFO after writing.

This setup requires the reader to be running before the writer sends data, as the FIFO read operation is blocking by default. You can handle this by running the reader in one terminal and the writer in another as instructed.

## Signals:

Signals are messages sent to a process to notify it of various events like segmentation faults, interrupts, etc. They can also be used for simple IPC.

## Message Queues:

Message queues allow processes to send and receive messages, facilitating complex communications by storing messages in a queue managed by the kernel until the recipient retrieves them.

## Semaphores:

Semaphores are used primarily for managing access to shared resources by multiple processes. They act as counters that control how many processes can access a resource simultaneously.

## Shared Memory:

This allows multiple processes to access the same segment of physical memory. It’s the fastest form of IPC because data does not need to be copied between the client and the server.

## Sockets:

Sockets provide a way for processes to communicate, potentially across different machines over a network. They support both connection-oriented and connectionless communication.

## Memory Mapped Files:

Memory mapping allows files or devices to be mapped into memory space, which can be shared between multiple processes.
Each method has its own use cases, advantages, and limitations, and the choice of IPC mechanism largely depends on the specific needs of the application and the system architecture.